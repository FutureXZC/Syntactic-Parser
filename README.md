# 编译原理语法分析器程序  
&emsp;&emsp;用户可根据要求输入任意自定义文法，程序会自动消除给定文法的左递归并求出分析表，用户可以用此文法生成的LL(1)分析表来分析一个字符串。  
&emsp;&emsp;输入的要求：自定义标识符统一标识为i，用户必须在程序一开始就明确文法的开始符号。  
**&emsp;&emsp;示例：**  
&emsp;&emsp;给定的测试用例文法G[E]  
> &emsp;G[S] = {  
> &emsp;&emsp;'S':'Qc|c',  
> &emsp;&emsp;'Q':'Rb|b',  
> &emsp;&emsp;'R':'Sa|a'  
> &emsp;}  
> &emsp;begin_ch = 'S'  

&emsp;&emsp;其中的i为用户自定义标识符，文法开始符号为E。程序会以此为基础消除左递归、求FIRST和FOLLOW集以及构造LL(1)文法分析表。分析表表头的'#'代表句子的结束标识符，表项中的'#'代表空符号串。用户可以再输入字符串来分析该串是否属于本文法。  
&emsp;&emsp;本例中的文法分析'cabcabc'结果如下所示：  
```
*****初始文法*****
S -> Qc | c
Q -> Rb | b
R -> Sa | a
*****消除间接左递归*****
S -> c | bc | Sabc | abc
Q -> b | Sab | ab
R -> Sa | a
*****删除多余符号*****
S -> c | bc | Sabc | abc
*****消除直接左递归*****
S -> cP | bcP | abcP
P -> abcP | ''
*****非终结符集vn和终结符集vt*****
VN： ['S', 'P']
VT： ['c', 'b', 'a']
*****FIRST集*****
FIRST(S) = {'c', 'b', 'a'}
FIRST(P) = {'a', ''}
*****FOLLOW集*****
FOLLOW(S) = {'#'}
FOLLOW(P) = {'#'}
*****文法分析表*****
-----------------------------------------
|       c       b       a       #       |
-----------------------------------------
| S     cP      bcP     abcP            |
| P                     abcP    #       |
-----------------------------------------
*****开始分析目标串：' cabcabc '*****
******************************************************
分析栈： ['#', 'S']
余留串： ['#', 'c', 'b', 'a', 'c', 'b', 'a', 'c']
******************************************************
所用产生式： cP
分析栈： ['#', 'P', 'c']
余留串： ['#', 'c', 'b', 'a', 'c', 'b', 'a', 'c']
******************************************************
分析栈： ['#', 'P']
余留串： ['#', 'c', 'b', 'a', 'c', 'b', 'a']
******************************************************
所用产生式： abcP
分析栈： ['#', 'P', 'c', 'b', 'a']
余留串： ['#', 'c', 'b', 'a', 'c', 'b', 'a']
******************************************************
分析栈： ['#', 'P', 'c', 'b']
余留串： ['#', 'c', 'b', 'a', 'c', 'b']
******************************************************
分析栈： ['#', 'P', 'c']
余留串： ['#', 'c', 'b', 'a', 'c']
******************************************************
分析栈： ['#', 'P']
余留串： ['#', 'c', 'b', 'a']
******************************************************
所用产生式： abcP
分析栈： ['#', 'P', 'c', 'b', 'a']
余留串： ['#', 'c', 'b', 'a']
******************************************************
分析栈： ['#', 'P', 'c', 'b']
余留串： ['#', 'c', 'b']
******************************************************
分析栈： ['#', 'P', 'c']
余留串： ['#', 'c']
******************************************************
分析栈： ['#', 'P']
余留串： ['#']
******************************************************
所用产生式： #
分析栈： ['#']
余留串： ['#']
******************************************************
分析成功，该句子符合本文法。  
```
&emsp;&emsp;本程序主函数部分注释了一些测试样例可供演示，用户也可将自定义输入的功能模块解除注释，自行测试。  
如果您对LL(1)分析法没有了解，您可以先阅读该项目中的pdf，了解程序的基本流程，图片由本人用手机拍摄。（尽管区区两页未必能看懂）  
&emsp;&emsp;此外，对于消除左递归的内容，您可以点击下面的链接了解相关信息：  
*&emsp;&emsp;参考资料（内容同成都科技大学出版社课本P78-81）：[编译原理 消除左递归](https://blog.csdn.net/liyun123gx/article/details/19924993)*